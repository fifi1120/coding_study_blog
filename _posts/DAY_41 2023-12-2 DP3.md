很牛的做题方法：

# LC 343 拆分数字


DP五部曲：

1. 确定dp数组（dp table）以及下标的含义——问自己：dp[i]的定义为？答案：拆分数字i，得到的最大乘积为dp[i]——可以看到其实非常straightforward，就是题目要求的最后一步。
2. 确定递推公式【在推导dp[i]的时候，一定要时刻想着dp[i]的定义，否则容易跑偏。】dp[i] = max(dp[i], (i - j) * j, dp[i - j] * j) --> dp[i]是不继续拆开会不会乘积已经是最大的了？(i - j) * j是继续拆一个j会不会最后乘积更大？dp[i - j] * j是拆了j之后，继续再拆i-j会不会还有更大的乘积？
3. dp数组如何初始化 【有时候不一定要从dp[0]开始，看清楚题目要求】n>=2 dp[2]=1
4. 确定遍历顺序：【从前到后还是从后到前】比如要计算dp[5]，就一定会需要用到dp[4]，（想知道5怎么拆最大，先要知道4怎么拆最大）所以先要有dp[4]才能有dp[5]，从前往后。
5. 举例推导dp数组：【当i=1,2,3,4,5；dp[1],dp[2],dp[3].dp[4].dp[5]=,,,看是否符合题目要求】比如n=10
<img width="722" alt="image" src="https://github.com/fifi1120/fifi1120.github.io/assets/98888516/0b4ee6d7-ec6c-42f0-b8d5-323e5594b93e">



写代码五部曲：

1. 创建dp table：dp = [0] * (n + 1)—— 从0开始，看有几个格子-->n=10的话，有9个格子，i=2,3,4...,10 【请注意，即使前面n=0,1的时候是没有意义的，但是格子还是要从0开始存在，不然后面index全乱了。
2. 初始化 dp 数组: dp[2]=1
3. for loop：递推公式——看loop到哪一位，这里是看index——注意在这个for里，需要处理corner case：range(i,j) 如果i>j会报错。：从前往后，两层遍历（因为要拆数）
4. return dp[n]
5. 看下corner case：没有什么corner case，题目说n从2开始的

```
class Solution:
    def integerBreak(self, n: int) -> int:
        dp = [0] * (n+1)
        dp[2] = 1
        for i in range(2,n+1): #当然是i套j，i才是主体，j只是表示从开始拆分数字而已。
            for j in range(1, n // 2 + 1): # 从1开始遍历j，因为从1开始拆，每次加1。右括号是0.5j+1是因为如果要拆成2个数从乘积最大，是要拆分成近似相同的几个数相乘，这是个数学问题，所以最多最多1/2处就可以停止遍历了。
                dp[i] = max(dp[i], (i-j) * j, dp[i-j] * j)
        return dp[n]
```



# LC 96 多少种搜索二叉树

DP五部曲：

1. 确定dp数组（dp table）以及下标的含义——问自己：dp[i]的定义为？答案：i个不同元素节点组成的二叉搜索树的个数为dp[i] 
2. 确定递推公式【在推导dp[i]的时候，一定要时刻想着dp[i]的定义，否则容易跑偏。】 dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量] ----> dp[i] += dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量
3. dp数组如何初始化 【有时候不一定要从dp[0]开始，看清楚题目要求】dp[0] = 1
4. 确定遍历顺序：【从前到后还是从后到前】从前往后。i是从1到n，每次加一位。j是从1到i（或者n），每次加一位。
5. 举例推导dp数组：【当i=1,2,3,4,5；dp[1],dp[2],dp[3].dp[4].dp[5]=,,,看是否符合题目要求】
<img width="586" alt="image" src="https://github.com/fifi1120/fifi1120.github.io/assets/98888516/2e366494-317a-4323-a218-f8c219d4de15">


解答：
```
# 递推式子例子 n=3 dp[3]=dp[0]*dp[2]+dp[1]*dp[1]+dp[2]*dp[0] = 1*2 + 1*1 + 2*1 = 5

# dp[0]=1
# dp[1]=1
# dp[2]=2


class Solution:
    def numTrees(self, n: int) -> int:
        dp = [0] * (n+1)
        dp[0]=1
        for i in range(1,n+1): #外层循环是在不断求dp[1],dp[2],dp[3],...
            for j in range(0, i): #内层循环是相当于拆分二叉树，j表示左子树的节点个数，左子树的节点最少可以是0（没有左节点），最多可以是i-1（留一个给头节点，剩下的全是左子树）
                dp[i] += dp[j] * dp[i-1-j] #左子树的可能性种类*右子树的可能性种类
        return dp[n]
```
