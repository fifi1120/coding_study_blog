回溯其实就是暴力搜索解法

有recursion必有回溯

其实是一种暴力解法

几种适用场景：

1. 组合（无顺序）：在1 2 3 4 找出所有长度为2的组合

2. 切割：有多少种切割方法（在某种规则件下）

3. 子集：有多少种子集（在某种条件下）
  
5. 排列（有顺序）：N个数字（按某种规则）然后全排

6. 棋盘：N皇后、数独


# 把回溯法抽象成树形结构：

回溯法的精髓：在集合中递归查找子集。

用for loop横着遍历，用递归竖着遍历。


N叉树：

树的宽度是集合的大小（for循环遍历）；

树的深度是递归的深度。


### 回溯法的模板：

1. 递归函数（起名叫backtracking）没有返回值。

一般参数比较多：一般先写逻辑，看后面需要什么参数，就补上什么参数。

   
2. 处理

```
if 终止条件：
   （在叶子节点）收集结果放进结果集 #把刚刚放进数组的1 2放进结果集
      return
```

【只有子集问题是在每一个节点去收集结果，其他的问题都是在最下层节点（即叶子结点）收集结果】

3. 单层搜索逻辑：

```
for 集合的每一个元素: #for循环是进行树的横向遍历-本层节点个数
    处理节点 #把1 2放进一个数组
    递归函数 #递归是纵向遍历：在树形图里面一层层往下走
    回溯操作 #撤销处理节点的结果：比如我现在是1 2然后把2弹出去，把3加进去，变成1 3，再把3弹出去，再把4加进去，变成1 4。回溯是有必要的，不然加到后面就是1 2 3 4 。。。
    return
```


总模板：
```
def backtracking(参数):
  if 终止条件：
    存放结果
    return

  for 本层所有节点：
    处理节点
    backtracking(路径，选择列表)
    回溯（即撤回刚刚的处理结果）
```

