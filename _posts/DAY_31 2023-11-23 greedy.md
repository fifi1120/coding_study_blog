贪心就是局部最优推出全局最优。（常识）

贪心没有套路，背包问题也解决不了。只能解出钞票问题。

就是做过就会，没做过就不会。、。。。。。。。。

靠自己手动模拟，如果模拟可行，就可以试一试贪心策略（用反例法自己检测一下），如果不可行，可能需要动态规划。

### 不用去想怎么证明。。。就手动模拟+常识感觉局部最优->全局最优 + 没有反例，就可以试试贪心了。。。

## 思考过程：
1. 局部最优能不能推出全局最优
2. 有没有反例
3. 问题分解成子问题+找子问题的最优解



LC 455 发饼干

局部最优：大饼干给大胃口的小孩
全局最优：喂饱最多的小孩
```
class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        res = 0
        s.sort()
        g.sort()
        pointer_s = len(s)-1
        #应该外面是胃口，里面是饼干。
        #只用遍历一遍胃口，每次看胃口有没有满足条件的饼干。胃口的指针一步一次移动，饼干的指针只有在满足条件的时候才移动。
        #所以其实只需要一个for loop去遍历胃口，然后通过调整指针的位置选取饼干，这样就只用loop一遍。而且也不需要copy出g和s，用了指针就不需要删除原list中的元素去找是否重复了。。。
        for i in range(len(g)-1, -1, -1): 
            if pointer_s >= 0 and g[i] <= s[pointer_s]: #注意index的限制条件pointer_s >= 0一般都需要写在前面，这样就不会index range of range。
                res += 1
                pointer_s -= 1
        return res
```
