很牛的做题方法：

LC 343 拆分数字


DP五部曲：

1. 确定dp数组（dp table）以及下标的含义——问自己：dp[i]的定义为？答案：拆分数字i，得到的最大乘积为dp[i]——可以看到其实非常straightforward，就是题目要求的最后一步。
2. 确定递推公式【在推导dp[i]的时候，一定要时刻想着dp[i]的定义，否则容易跑偏。】dp[i] = max(dp[i], (i - j) * j, dp[i - j] * j) --> dp[i]是不继续拆开会不会乘积已经是最大的了？(i - j) * j是继续拆一个j会不会最后乘积更大？dp[i - j] * j是拆了j之后，继续再拆i-j会不会还有更大的乘积？
3. dp数组如何初始化 【有时候不一定要从dp[0]开始，看清楚题目要求】n>=2 dp[2]=1
4. 确定遍历顺序：【从前到后还是从后到前】比如要计算dp[5]，就一定会需要用到dp[4]，（想知道5怎么拆最大，先要知道4怎么拆最大）所以先要有dp[4]才能有dp[5]，从前往后。
5. 举例推导dp数组：【当i=1,2,3,4,5；dp[1],dp[2],dp[3].dp[4].dp[5]=,,,看是否符合题目要求】比如n=10
<img width="722" alt="image" src="https://github.com/fifi1120/fifi1120.github.io/assets/98888516/0b4ee6d7-ec6c-42f0-b8d5-323e5594b93e">



写代码五部曲：

创建dp table：dp = [0] * (n + 1)—— 从0开始，看有几个格子
初始化 dp 数组
for loop：递推公式——看loop到哪一位，这里是看index——注意在这个for里，需要处理corner case：range(i,j) 如果i>j会报错。
return dp[n]
看下corner case
